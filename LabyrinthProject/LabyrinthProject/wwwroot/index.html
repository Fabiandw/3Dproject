<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Labyrinth</title>
<<<<<<< HEAD
    <script type="text/javascript" src="three.min.js"></script>
    <script type="text/javascript" src="OrbitControls.js"></script>
    <script type="text/javascript" src="MTLLoader.js"></script>
    <script type="text/javascript" src="OBJLoader.js"></script>
</head>

<body style="margin:0px;padding:0px;overflow:hidden;">
    <div id="viewport"></div>

    <script type="text/javascript">
=======
    <link rel="stylesheet" type="text/css" href="css/index.css" />

    <script src="three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="MTLLoader.js"></script>
    <script src="OBJLoader.js"></script>

    <style>
        #loadingText {
            width: 500px;
            height: 10px;
            position: absolute;
            top: 75%;
            width: 100%;
            text-align: center;
        }

        #title {
            width: 200px;
            height: 10px;
            position: absolute;
            top: 2%;
            width: 100%;
            text-align: center;
        }

        #userInterface {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0%;
            width: 100%;
            text-align: center;
        }

        #topspan {
            position: absolute;
            top: 8px;
            left: 16px;
        }

        #level {
            position: absolute;
            top: 8px;
            right: 16px;
        }

        #controls {
            position: absolute;
            bottom: 8px;
        }

        #date {
            position: absolute;
            bottom: 8px;
            right: 16px;
        }

        #wasd {
            position: absolute;
            bottom: 8px;
            left: 16px;
            font-size: 18px;
        }
    </style>

</head>

<body style="margin:0px;padding:0px;overflow:hidden;">

    <div id="loadingText">Please wait while we load the world for you...</div>

    <div id="title">3D Labyrinth</div>

    <div id="userInterface">
        <button class="level" id="level" align="left">Level: 1</button>
        <div id="topspan">
            <img class="keys" src="textures/keyBlack.png" alt="key" id="key1" width="75" height="75" />
            <img class="keys" src="textures/keyBlack.png" alt="key" id="key2" width="75" height="75" />
        </div>
        <div id="controls">
            <span id="date"></span>
            <paragraph id="wasd">
                <p align="left">W: Move Forwards</p>
                <p align="left">S: Move Backwards</p>
                <p align="left">A: Move Left</p>
                <p align="left">D: Move Right</p>
                <p align="left">Q: Rotate Left</p>
                <p align="left">E: Rotate Right</p>
                <p align="left">Arrow keys also rotate</p>
            </paragraph>
        </div>
    </div>



    <script>
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
        function parseCommand(input = "") {
            return JSON.parse(input);
        }

        var meshFloor, ambientLight, light;
        var crate, crateTexture, crateNormalMap, crateBumpMap;
        var keyboard = {};
<<<<<<< HEAD
        var collidableMeshList = [];
        var player = { height: 0, speed: 0.05, turnSpeed: Math.PI * 0.02 };
        var playerHitbox;

        var renderer, scene, camera;
        var cameraControls;
        var exampleSocket;

        var rays = [
            new THREE.Vector3(0, 0, 1), // X = | Z +
            new THREE.Vector3(1, 0, 1), // X + | Z +
            new THREE.Vector3(1, 0, 0), // X + | Z =
            new THREE.Vector3(1, 0, -1), // X + | Z -
            new THREE.Vector3(0, 0, -1), // X = | Z -
            new THREE.Vector3(-1, 0, -1), // X - | Z -
            new THREE.Vector3(-1, 0, 0), // X - | Z =
            new THREE.Vector3(-1, 0, 1) // X - | Z +
        ];

        var caster = new THREE.Raycaster();
        var collisionX;
        var collisionZ;

        var worldObjects = {};

        function init() {
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight + 5);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            document.getElementById('viewport').appendChild(renderer.domElement);

            // Scene
            scene = new THREE.Scene;

            // Camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);

            //cameraControls = new THREE.OrbitControls(camera);
            //camera.position.set(-25, 30, -25);
=======
        var keyAmount = 0;
        var reqKeys = 2;
        var USE_WIREFRAME = false;

        var scene, camera, renderer;
        var loadingManager;
        var cameraControls;
        var exampleSocket;
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(), INTERSECTED;
        var radius = 100, theta = 0;
        var worldObjects = {};

        var rays = [
            new THREE.Vector3(0, 0, 1), // X = | Z +
            new THREE.Vector3(1, 0, 1), // X + | Z +
            new THREE.Vector3(1, 0, 0), // X + | Z =
            new THREE.Vector3(1, 0, -1), // X + | Z -
            new THREE.Vector3(0, 0, -1), // X = | Z -
            new THREE.Vector3(-1, 0, -1), // X - | Z -
            new THREE.Vector3(-1, 0, 0), // X - | Z =
            new THREE.Vector3(-1, 0, 1) // X - | Z +
        ];
        var caster = new THREE.Raycaster();
        var collisionX;
        var collisionZ;
        var collidableMeshList = [];
        var player = { height: 0, speed: 0.04, turnSpeed: Math.PI * 0.02 };
        var playerHitbox;


        function updateTime() {

            var dt = new Date();
            document.getElementById("date").innerHTML = dt.toLocaleTimeString();
        }
        setInterval(updateTime, 1000);

        var button = document.getElementById("level"),
            count = 0;
        button.onclick = function () {
            count += 1;
            button.innerHTML = "Level: " + count;
        };

        var loadingScreen = {
            scene: new THREE.Scene(),
            camera: new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100),
            box: new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 0.5),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader(loadingManager).load("textures/pepe.jpg") })
            )
        };

        var RESOURCES_LOADED = false;

        function init() {
            // Loading screen
            loadingScreen.box.position.set(0, 0, 2);
            loadingScreen.camera.lookAt(loadingScreen.box.position);
            loadingScreen.scene.add(loadingScreen.box);

            // Loading manager
            loadingManager = new THREE.LoadingManager();
            loadingManager.onLoad = function () {
                RESOURCES_LOADED = true;
            }

            requestAnimationFrame(animate);

            // Camera
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 4);

            //cameraControls = new THREE.OrbitControls(camera);
            //camera.position.x = -50;
            //camera.position.y = 30;
            //camera.position.z = -50;;
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
            //cameraControls.update();

            //camera.position.set(1, player.height, 1);
            //camera.lookAt(new THREE.Vector3(2, player.height, 2));
<<<<<<< HEAD

=======
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', keyDown);
            window.addEventListener('keyup', keyUp);

<<<<<<< HEAD
            // Plane
            var planeGeometry = new THREE.PlaneGeometry(100, 100, 32);
            var planeMaterial = new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/moonsurface.jpg"), side: THREE.DoubleSide });
            var plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            plane.position.y = -0.5
            scene.add(plane);
=======
            // Interaction
            // window.addEventListener('mousemove', onMouseMove, false);

            // Floor
            var floorTexture = new THREE.ImageUtils.loadTexture('textures/floor.jpg');
            floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;

            floorTexture.repeat.set(100, 100);
            var floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture, side: THREE.DoubleSide });
            var floorGeometry = new THREE.PlaneGeometry(50, 50, 10, 10);

            var floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.y = -0.5;
            floor.rotation.x = Math.PI / 2;
            //scene.add(floor);
            floortje = new THREE.Group();
            floortje.add(floor);
            scene.add(floortje);

            // Roof
            var roofTexture = new THREE.ImageUtils.loadTexture('textures/roof.jpg');
            roofTexture.wrapS = roofTexture.wrapT = THREE.RepeatWrapping;

            roofTexture.repeat.set(60, 60);
            var roofMaterial = new THREE.MeshPhongMaterial({ map: roofTexture, side: THREE.DoubleSide });
            var roofGeometry = new THREE.PlaneGeometry(50, 50, 10, 10);

            var roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 0.5;
            roof.rotation.x = Math.PI / 2;
            scene.add(roof);
            roofje = new THREE.Group();
            roofje.add(roof);
            scene.add(roofje);

            //Playerlight
            var playerLight = new THREE.PointLight(0xff9933, 0.8, 3.5, 2);
            playerLight.castShadow = true;
            playerLight.shadow.radius = 1.05;
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa

            // Player
            var hitboxGeometery = new THREE.CylinderGeometry(0.25, 0.25, 0.8, 8);
            var hitboxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            playerHitbox = new THREE.Mesh(hitboxGeometery, hitboxMaterial);
<<<<<<< HEAD
            playerHitbox.position.set(1, -0.1, 1);
            playerHitbox.lookAt(new THREE.Vector3(-2, player.height - 0.1, -2));
=======
            //playerHitbox.position.set(1, -0.1, 1);
            playerHitbox.lookAt(new THREE.Vector3(-Math.PI, player.height, -Math.PI));
            playerHitbox.add(playerLight);
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
            scene.add(playerHitbox);
            playerHitbox.add(camera);

            // Ambient Light
<<<<<<< HEAD
            ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            //Loading in models
=======
            //var ambientlight = new THREE.AmbientLight(0x666666); // soft hard light
            //scene.add(ambientlight);

            // Render
            renderer = new THREE.WebGLRenderer();
            renderer.physicallyCorrectLights = true;
            renderer.gammaInput = true;
            renderer.gammaOutput = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.bias = 0.0001;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight + 5);
            document.body.appendChild(renderer.domElement);

            // Loading in models
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
            modelDeployer();

            requestAnimationFrame(animate);
        }
<<<<<<< HEAD

        // WindowResize [Function]
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animate [Function]
        function animate() {
            rotate();
            movement();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        function keyDown(event) {
            keyboard[event.keyCode] = true;
        }

        function keyUp(event) {
            keyboard[event.keyCode] = false;
        }

        function collision() {
            var collisions, i,
                distance = 0.25,
                obstacles = collidableMeshList;

            collisionX = 0;
            collisionZ = 0;

            for (i = 0; i < rays.length; i += 1) {
                caster.set(playerHitbox.position, rays[i]);
                collisions = caster.intersectObjects(obstacles);

                if (collisions.length > 0 && collisions[0].distance <= distance) {
                    if ((i === 1 || i === 2 || i === 3)) {
                        collisionX = 1;
                    } else if ((i === 5 || i === 6 || i === 7)) {
                        collisionX = -1;
                    }
                    if ((i === 0 || i === 1 || i === 7)) {
                        collisionZ = 1;
                    } else if ((i === 3 || i === 4 || i === 5)) {
                        collisionZ = -1;
                    }
                }
            }
        }

        function rotate() {
            if (!((keyboard[87] || keyboard[83]) && (keyboard[65] || keyboard[68]))) {
                if (keyboard[81]) { // Q key
                    playerHitbox.rotation.y -= player.turnSpeed;
                }
                else if (keyboard[37]) { // Left arrow key
                    playerHitbox.rotation.y -= player.turnSpeed;
                }
                if (keyboard[69]) { // E key
                    playerHitbox.rotation.y += player.turnSpeed;
                }
                else if (keyboard[39]) { // Right arrow key
                    playerHitbox.rotation.y += player.turnSpeed;
                }
            }
        }

        function movement() {
            collision();
            var position = playerHitbox.position.clone();
            var moveX;
            var moveZ;

            if (keyboard[87]) { // W key
                if (position.x < position.x - Math.sin(playerHitbox.rotation.y) * player.speed) {
                    if (collisionX !== 1) {
                        moveX = true;
                    }
                }
                else if (position.x > position.x - Math.sin(playerHitbox.rotation.y) * player.speed) {
                    if (collisionX !== -1) {
                        moveX = true;
                    }
=======

        // WindowResize [Function]
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animate [Function]
        function animate() {
            if (RESOURCES_LOADED === false) {
                requestAnimationFrame(animate);

                var loadingText = document.getElementById('loadingText');
                loadingText.style.visibility = "visible";

                var userInterface = document.getElementById('userInterface');
                userInterface.style.visibility = "hidden";

                loadingScreen.box.rotation.x -= 0.01;
                loadingScreen.box.rotation.y -= 0.01;
                loadingScreen.box.rotation.z -= 0.01;

                renderer.render(loadingScreen.scene, loadingScreen.camera);
                return;
            }

            if (RESOURCES_LOADED === true) {
                requestAnimationFrame(animate);

                var loadingText = document.getElementById('loadingText');
                loadingText.style.visibility = "hidden";

                var userInterface = document.getElementById('userInterface');
                userInterface.style.visibility = "visible";

                renderer.render(scene, camera);
            }
            rotate();
            movement();
            keyCheck();
        }

        function keyDown(event) {
            keyboard[event.keyCode] = true;
        }

        function keyUp(event) {
            keyboard[event.keyCode] = false;
        }

        function rotate() {
            if (keyboard[81]) { // Q key
                playerHitbox.rotation.y -= player.turnSpeed;
            }
            else if (keyboard[37]) { // Left arrow key
                playerHitbox.rotation.y -= player.turnSpeed;
            }
            if (keyboard[69]) { // E key
                playerHitbox.rotation.y += player.turnSpeed;
            }
            else if (keyboard[39]) { // Right arrow key
                playerHitbox.rotation.y += player.turnSpeed;
            }
        }

        function movement() {
            collision();
            var sin = Math.sin(playerHitbox.rotation.y);
            var sinPi = Math.sin(playerHitbox.rotation.y + Math.PI / 2);
            var cos = Math.cos(playerHitbox.rotation.y);
            var cosPi = Math.cos(playerHitbox.rotation.y + Math.PI / 2);

            if (keyboard[87]) { // W key
                if ((sin < 0 && collisionX < 1) || (sin > 0 && collisionX > -1)) {
                    playerHitbox.position.x -= sin * player.speed;
                }

                if ((cos > 0 && collisionZ < 1) || (cos < 0 && collisionZ > -1)) {
                    playerHitbox.position.z += cos * player.speed;
                }
            }

            if (keyboard[83]) { // S key

                if ((sin > 0 && collisionX < 1) || (sin < 0 && collisionX > -1)) {
                    playerHitbox.position.x += sin * player.speed;

                }
                if ((cos < 0 && collisionZ < 1) || (cos > 0 && collisionZ > -1)) {
                    playerHitbox.position.z -= cos * player.speed;
                }
            }

            if (keyboard[65]) { // A key
                if ((sinPi > 0 && collisionX < 1) || (sinPi < 0 && collisionX > -1)) {
                    playerHitbox.position.x += sinPi * player.speed;
                }

                if ((cosPi < 0 && collisionZ < 1) || (cosPi > 0 && collisionZ > -1)) {
                    playerHitbox.position.z -= cosPi * player.speed;
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
                }
            }

<<<<<<< HEAD
                if (position.z < position.z - -Math.cos(playerHitbox.rotation.y) * player.speed) {
                    if (collisionZ !== 1) {
                        moveZ = true;
                    }
                }
                else if (position.z > position.z - -Math.cos(playerHitbox.rotation.y) * player.speed) {
                    if (collisionZ !== -1) {
                        moveZ = true;
                    }
                }

                if (moveX === true && moveZ === true) {
                    playerHitbox.position.x -= Math.sin(playerHitbox.rotation.y) * player.speed;
                    playerHitbox.position.z -= -Math.cos(playerHitbox.rotation.y) * player.speed;
                }
            }

            if (keyboard[83]) { // S key
                if (position.x < position.x + Math.sin(playerHitbox.rotation.y) * player.speed) {
                    if (collisionX !== 1) {
                        moveX = true;
                    }
                }
                else if (position.x > position.x + Math.sin(playerHitbox.rotation.y) * player.speed) {
                    if (collisionX !== -1) {
                        moveX = true;
                    }
                }

                if (position.z < position.z + -Math.cos(playerHitbox.rotation.y) * player.speed) {
                    if (collisionZ !== 1) {
                        moveZ = true;
                    }
                }
                else if (position.z > position.z + -Math.cos(playerHitbox.rotation.y) * player.speed) {
                    if (collisionZ !== -1) {
                        moveZ = true;
                    }
                }

                if (moveX === true && moveZ === true) {
                    playerHitbox.position.x += Math.sin(playerHitbox.rotation.y) * player.speed;
                    playerHitbox.position.z += -Math.cos(playerHitbox.rotation.y) * player.speed;
                }
            }

            if (keyboard[65]) { // A key
                if (position.x < position.x + Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionX !== 1) {
                        moveX = true;
                    }
                }
                else if (position.x > position.x + Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionX !== -1) {
                        moveX = true;
                    }
                }

                if (position.z < position.z + -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionZ !== 1) {
                        moveZ = true;
                    }
                }
                else if (position.z > position.z + -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionZ !== -1) {
                        moveZ = true;
                    }
                }

                if (moveX === true && moveZ === true) {
                    playerHitbox.position.x += Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed;
                    playerHitbox.position.z += -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed;
                }
=======
            if (keyboard[68]) { // D key
                if ((sinPi < 0 && collisionX < 1) || (sinPi > 0 && collisionX > -1)) {
                    playerHitbox.position.x -= sinPi * player.speed;
                }

                if ((cosPi > 0 && collisionZ < 1) || (cosPi < 0 && collisionZ > -1)) {
                    playerHitbox.position.z += cosPi * player.speed;
                }
            }
        }

        function collision() {
            var collisions, i,
                distance = 0.25,
                obstacles = collidableMeshList;

            collisionX = 0;
            collisionZ = 0;

            for (i = 0; i < rays.length; i += 1) {
                caster.set(playerHitbox.position, rays[i]);
                collisions = caster.intersectObjects(obstacles);

                if (collisions.length > 0 && collisions[0].distance <= distance) {
                    if ((i === 1 || i === 2 || i === 3)) {
                        collisionX = 1;
                    } else if ((i === 5 || i === 6 || i === 7)) {
                        collisionX = -1;
                    }
                    if ((i === 0 || i === 1 || i === 7)) {
                        collisionZ = 1;
                    } else if ((i === 3 || i === 4 || i === 5)) {
                        collisionZ = -1;
                    }
                }
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
            }
        }

        function keyCheck() {
            // Cast a ray in front of the camera
            var target = new THREE.Vector3(camera.x, camera.y + 0.5, camera.z);
            raycaster.setFromCamera(target, camera);
            // calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0 && intersects[0].distance < 0.2) {
                switch (intersects[0].object.type) {
                    case 'key':
                        keyAmount++;
                        scene.remove(intersects[0].object);
                        if (keyAmount === 1) {
                            document.getElementById("key1").src = "textures/keyYellow.png";

<<<<<<< HEAD
            if (keyboard[68]) { // D key
                if (position.x < position.x - Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionX !== 1) {
                        moveX = true;
                    }
                }
                else if (position.x > position.x - Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionX !== -1) {
                        moveX = true;
                    }
                }

                if (position.z < position.z - -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionZ !== 1) {
                        moveZ = true;
                    }
                }
                else if (position.z > position.z - -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionZ !== -1) {
                        moveZ = true;
                    }
                }

                if (moveX === true && moveZ === true) {
                    playerHitbox.position.x -= Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed;
                    playerHitbox.position.z -= -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed;
=======
                        }
                        if (keyAmount === 2) {
                            document.getElementById("key2").src = "textures/keyYellow.png";
                        }
                        break;
                    case 'end':
                        if (keyAmount === reqKeys) {
                            alert("End");
                        }
                        break;

                    default:
                        break;
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
                }
            }
        }

<<<<<<< HEAD
        // Model Loader [Function]
        function loadOBJModel(modelPath, modelName, texturePath, textureName, onload) {
            new THREE.MTLLoader()
=======
        function loadOBJModel(modelPath, modelName, texturePath, textureName, onload) {
            new THREE.MTLLoader(loadingManager)
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
                .setPath(texturePath)
                .load(textureName, function (materials) {

                    materials.preload();

<<<<<<< HEAD
                    new THREE.OBJLoader()
=======
                    new THREE.OBJLoader(loadingManager)
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
                        .setPath(modelPath)
                        .setMaterials(materials)
                        .load(modelName, function (object) {
                            onload(object);
                        }, function () { }, function (e) { console.log("Error loading model"); console.log(e); });
                });
        }

<<<<<<< HEAD
=======
        function createLight(x, y, z) {
            var torchLight = new THREE.PointLight(0xff9933, 0.65, 1, 2);
            //torchLight.castShadow = true;
            torchLight.shadowDarkness = 0.5;
            torchLight.shadow.radius = 1;
            torchLight.position.set(x, y, z);
            scene.add(torchLight);
            //alert("light pos " + torchLight.position.x + torchLight.position.y + torchLight.position.z);
            return torchLight;
        }

>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
        // Model Deployer [Server]
        function modelDeployer() {
            exampleSocket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/connect_client");
            exampleSocket.onmessage = function (event) {
                var command = parseCommand(event.data);
                console.log(command);
                if (command.command === "update") {
                    if (Object.keys(worldObjects).indexOf(command.parameters.guid) < 0) {
                        switch (command.parameters.type) {
                            case "wall":
<<<<<<< HEAD
                                {
                                    //Position and Dimensions need to be optained from the object, but idk if this works
                                    var geometry = new THREE.BoxGeometry(1, 1, 0.05);
                                    var material = new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/wolla.jpg"), side: THREE.DoubleSide });
                                    var wall = new THREE.Mesh(geometry, material);
                                    scene.add(wall);
                                    collidableMeshList.push(wall);
                                    worldObjects[command.parameters.guid] = wall;
                                }
=======
                                //Position and Dimensions need to be obtained from the object, but idk if this works
                                var geometry = new THREE.BoxGeometry(1, 1, 0.07);
                                var material = new THREE.MeshLambertMaterial({ map: new THREE.TextureLoader(loadingManager).load("textures/wall.jpg"), side: THREE.DoubleSide/*, transparent: true, opacity: 0.2 */ });
                                var wall = new THREE.Mesh(geometry, material);
                                var walls = new THREE.Group();
                                wall.castShadow = true;
                                walls.add(wall);
                                scene.add(walls);
                                collidableMeshList.push(wall);
                                worldObjects[command.parameters.guid] = walls;

>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
                                break;

                            case "room":
                                switch (command.parameters.roomType) {
                                    case "start":
                                        playerHitbox.position.set(command.parameters.x, player.height, command.parameters.z);
                                        var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                        var mat = new THREE.MeshLambertMaterial({ map: new THREE.TextureLoader(loadingManager).load("textures/start.png"), side: THREE.DoubleSide });
                                        var start = new THREE.Mesh(geo, mat);
                                        scene.add(start);
                                        worldObjects[command.parameters.guid] = start;

                                        break;

                                    case "end":
                                        var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                        var mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
                                        var end = new THREE.Mesh(geo, mat);
                                        end.type = "end";
                                        scene.add(end);
                                        worldObjects[command.parameters.guid] = end;

                                        loadOBJModel("textures/Decoration/", "keyhole.obj", "textures/Decoration/", "keyhole.mtl", (lock) => {
                                            lock.scale.set(0.07, 0.07, 0.07);
                                            lock.position.set(command.parameters.x, command.parameters.y - 0.2, command.parameters.z);
                                            scene.add(lock);
                                        });
                                        createLight(command.parameters.x, command.parameters.y, command.parameters.z);

                                        break;

                                    case "puzzle":
                                        var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                        var mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
                                        var key = new THREE.Mesh(geo, mat);
                                        key.type = "key";

                                        loadOBJModel("textures/Decoration/", "key.obj", "textures/Decoration/", "key.mtl", (oldkey) => {
                                            oldkey.scale.set(1, 1, 1);
                                            key.add(oldkey);
                                            worldObjects[command.parameters.guid] = oldkey;
                                        });
                                        scene.add(key);
                                        worldObjects[command.parameters.guid] = key;

                                        createLight(command.parameters.x, command.parameters.y, command.parameters.z);

                                        break;
                                }

                            case "decoration":
                                //var decorations = new THREE.Group();
                                //worldObjects[command.parameters.guid] = decorations;
                                switch (command.parameters.decoType) {
                                    case "torch":
                                        var torches = new THREE.Group();
                                        worldObjects[command.parameters.guid] = torches;
                                        loadOBJModel("textures/Decoration/", "walltorch.obj", "textures/Decoration/", "walltorch.mtl", (mesh) => {
                                            mesh.scale.set(1, 1, 1);
                                            torches.add(mesh);
                                            scene.add(torches);
                                        });
                                        createLight(command.parameters.x, command.parameters.y - 0.15, command.parameters.z);

                                        break;
                                }

                                break;
                        }
                    }

                    // Object Parameters
                    var object = worldObjects[command.parameters.guid];
                    object.position.x = command.parameters.x;
                    object.position.y = command.parameters.y;
                    object.position.z = command.parameters.z;
                    object.rotation.x = command.parameters.rotationX;
                    object.rotation.y = command.parameters.rotationY;
                    object.rotation.z = command.parameters.rotationZ;
                }
            };
        }

        window.onload = init();
<<<<<<< HEAD
    </script>
=======

    </script>
<<<<<<< HEAD
    <embed name="GoodEnough" src="/textures/song.mp3" loop="false" hidden="true" autostart="true">
>>>>>>> 0dbe6996194354433c01c5bbbd245a848a78ebaa
=======
    <embed name="GoodEnough" src="/textures/song.mp3" loop="false" hidden autostart="true">
>>>>>>> edb9666b5fb1c026c1600d45e5dda228f068695a
</body>

</html>