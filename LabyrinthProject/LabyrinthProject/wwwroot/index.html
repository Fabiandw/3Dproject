<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Labyrinth</title>
    <link rel="stylesheet" type="text/css" href="css/index.css" />
    <link rel="stylesheet" href="Main.css" type="text/css" />

    <script type="text/javascript" src="three.min.js"></script>
    <script type="text/javascript" src="OrbitControls.js"></script>
    <script type="text/javascript" src="MTLLoader.js"></script>
    <script type="text/javascript" src="OBJLoader.js"></script>

    <style>
        #loadingText {
            width: 500px;
            height: 10px;
            position: absolute;
            top: 75%;
            width: 100%;
            text-align: center;
        }

        #title {
            width: 200px;
            height: 10px;
            position: absolute;
            top: 2%;
            width: 100%;
            text-align: center;
        }

        #userInterface {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0%;
            width: 100%;
            text-align: center;
        }

        #topspan {
            position: absolute;
            top: 8px;
            left: 16px;
        }

        #level {
            position: absolute;
            top: 8px;
            right: 16px;
        }

        #controls {
            position: absolute;
            bottom: 8px;
        }

        #date {
            position: absolute;
            bottom: 8px;
            right: 16px;
        }

        #wasd {
            position: absolute;
            bottom: 8px;
            left: 16px;
            font-size: 18px;
        }
    </style>


</head>

<body style="margin:0px;padding:0px;overflow:hidden;">

    <div class="hud" id=" hud" display="none">
        <div id="loadingText">Please wait while we load the world for you...</div>

        <div id="title">3D Labyrinth</div>

        <div id="userInterface">
            <button class="level" id="level" align="left">Level: 1</button>
            <div id="topspan">
                <img class="keys" src="textures/keyBlack.png" alt="key" id="key1" width="75" height="75" />
                <img class="keys" src="textures/keyBlack.png" alt="key" id="key2" width="75" height="75" />
            </div>
            <div id="controls">
                <span id="date"></span>
                <paragraph id="wasd">
                    <p align="left">W: Move Forwards</p>
                    <p align="left">S: Move Backwards</p>
                    <p align="left">A: Move Left</p>
                    <p align="left">D: Move Right</p>
                    <p align="left">Q: Rotate Left</p>
                    <p align="left">E: Rotate Right</p>
                    <p align="left">M: Mute Music</p>
                    <p align="left">⬅️/➡️ rotate</p>
                    <p align="left">⬆️/⬇️ volume</p>
                </paragraph>
            </div>
        </div>
    </div>
    <script>
        function parseCommand(input = "") {
            return JSON.parse(input);
        }

        var meshFloor, ambientLight, light;
        var crate, crateTexture, crateNormalMap, crateBumpMap;
        var keyboard = {};
        var collidableMeshList = [];
        var player = { height: 0, speed: 0.05, turnSpeed: Math.PI * 0.02 };
        var playerHitbox;

        var renderer, scene, camera;
        var cameraControls;
        var exampleSocket;

        var keyAmount = 0;
        var reqKeys = 2;

        var raycaster = new THREE.Raycaster();
        var worldObjects = {};

        var soundMusic;

        var rays = [
            new THREE.Vector3(0, 0, 1), // X = | Z +
            new THREE.Vector3(1, 0, 1), // X + | Z +
            new THREE.Vector3(1, 0, 0), // X + | Z =
            new THREE.Vector3(1, 0, -1), // X + | Z -
            new THREE.Vector3(0, 0, -1), // X = | Z -
            new THREE.Vector3(-1, 0, -1), // X - | Z -
            new THREE.Vector3(-1, 0, 0), // X - | Z =
            new THREE.Vector3(-1, 0, 1) // X - | Z +
        ];
        var caster = new THREE.Raycaster();
        var collisionX;
        var collisionZ;


        function updateTime() {

            var dt = new Date();

            var volume = soundMusic.getVolume() * 100;
            var volume2 = Math.round(volume);

            document.getElementById("date").innerHTML = "Volume: " + volume2 + "%";
        }
        setInterval(updateTime, 2);

        var button = document.getElementById("level"),
            count = 0;
        button.onclick = function () {
            count += 1;
            button.innerHTML = "Level: " + count;
        };

        var loadingScreen = {
            scene: new THREE.Scene(),
            camera: new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100),
            box: new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 0.5),
                new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader(loadingManager).load("textures/pepe.jpg") })
            )
        };

        var loadingManager;
        var RESOURCES_LOADED = false;

        function init() {


            // Loading screen
            loadingScreen.box.position.set(0, 0, 2);
            loadingScreen.camera.lookAt(loadingScreen.box.position);
            loadingScreen.scene.add(loadingScreen.box);

            // Loading manager
            loadingManager = new THREE.LoadingManager();
            loadingManager.onLoad = function () {
                RESOURCES_LOADED = true;
            }

            requestAnimationFrame(animate);

            // Camera
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 4);

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', keyDown);
            window.addEventListener('keyup', keyUp);

            // Floor
            var floorTexture = new THREE.ImageUtils.loadTexture('textures/floor.jpg');
            floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;

            floorTexture.repeat.set(100, 100);
            var floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture, side: THREE.DoubleSide });
            var floorGeometry = new THREE.PlaneGeometry(50, 50, 10, 10);

            var floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.y = -0.5;
            floor.rotation.x = Math.PI / 2;
            floortje = new THREE.Group();
            floortje.add(floor);
            scene.add(floortje);

            //Music
            // create an AudioListener and add it to the camera
            var listener = new THREE.AudioListener();
            camera.add(listener);

            // create a global audio source
            soundMusic = new THREE.Audio(listener);

            // load a sound and set it as the Audio object's buffer
            var audioLoader = new THREE.AudioLoader();
            audioLoader.load('textures/song.mp3', function (buffer) {
                soundMusic.setBuffer(buffer);
                soundMusic.setLoop(true);
                soundMusic.setVolume(0.2);
                soundMusic.play();
            });

            // Roof
            var roofTexture = new THREE.ImageUtils.loadTexture('textures/roof.jpg');
            roofTexture.wrapS = roofTexture.wrapT = THREE.RepeatWrapping;

            roofTexture.repeat.set(60, 60);
            var roofMaterial = new THREE.MeshPhongMaterial({ map: roofTexture, side: THREE.DoubleSide });
            var roofGeometry = new THREE.PlaneGeometry(50, 50, 10, 10);

            var roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 0.5;
            roof.rotation.x = Math.PI / 2;
            scene.add(roof);
            roofje = new THREE.Group();
            roofje.add(roof);
            scene.add(roofje);

            // Playerlight
            var playerLight = new THREE.PointLight(0xff9933, 0.8, 3.5, 2);
            playerLight.castShadow = true;
            playerLight.shadow.radius = 1.05;

            // Player
            var hitboxGeometery = new THREE.CylinderGeometry(0.25, 0.25, 0.8, 8);
            var hitboxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            playerHitbox = new THREE.Mesh(hitboxGeometery, hitboxMaterial);
            playerHitbox.position.set(1, -0.1, 1);
            playerHitbox.lookAt(new THREE.Vector3(-2, player.height - 0.1, -2));
            playerHitbox.lookAt(new THREE.Vector3(-Math.PI, player.height, -Math.PI));
            playerHitbox.add(playerLight);
            scene.add(playerHitbox);
            playerHitbox.add(camera);

            // Render
            renderer = new THREE.WebGLRenderer();
            renderer.physicallyCorrectLights = true;
            renderer.gammaInput = true;
            renderer.gammaOutput = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.bias = 0.0001;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight + 5);
            document.body.appendChild(renderer.domElement);

            // Loading in models
            modelDeployer();

            requestAnimationFrame(animate);
        }

        // WindowResize [Function]
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animate [Function]
        function animate() {

            if (RESOURCES_LOADED === false) {
                requestAnimationFrame(animate);

                var loadingText = document.getElementById('loadingText');
                loadingText.style.visibility = "visible";

                var userInterface = document.getElementById('userInterface');
                userInterface.style.visibility = "hidden";

                loadingScreen.box.rotation.x -= 0.01;
                loadingScreen.box.rotation.y -= 0.01;
                loadingScreen.box.rotation.z -= 0.01;

                renderer.render(loadingScreen.scene, loadingScreen.camera);
                return;
            }

            if (RESOURCES_LOADED === true) {
                requestAnimationFrame(animate);

                var loadingText = document.getElementById('loadingText');
                loadingText.style.visibility = "hidden";

                var userInterface = document.getElementById('userInterface');
                userInterface.style.visibility = "visible";

                renderer.render(scene, camera);
            }
            rotate();
            movement();
            audio();
            keyCheck();
        }

        function keyDown(event) {
            keyboard[event.keyCode] = true;
        }

        function keyUp(event) {
            keyboard[event.keyCode] = false;
        }

        function rotate() {
            if (keyboard[81]) { // Q key
                playerHitbox.rotation.y -= player.turnSpeed;
            }
            else if (keyboard[37]) { // Left arrow key
                playerHitbox.rotation.y -= player.turnSpeed;
            }
            if (keyboard[69]) { // E key
                playerHitbox.rotation.y += player.turnSpeed;
            }
            else if (keyboard[39]) { // Right arrow key
                playerHitbox.rotation.y += player.turnSpeed;
            }

            if (keyboard[75]) {
                restart();
            }
        }

        function movement() {
            collision();
            var sin = Math.sin(playerHitbox.rotation.y);
            var sinPi = Math.sin(playerHitbox.rotation.y + Math.PI / 2);
            var cos = Math.cos(playerHitbox.rotation.y);
            var cosPi = Math.cos(playerHitbox.rotation.y + Math.PI / 2);

            if (keyboard[87]) { // W key
                if ((sin < 0 && collisionX < 1) || (sin > 0 && collisionX > -1)) {
                    playerHitbox.position.x -= sin * player.speed;
                }

                if ((cos > 0 && collisionZ < 1) || (cos < 0 && collisionZ > -1)) {
                    playerHitbox.position.z += cos * player.speed;
                }
            }

            if (keyboard[83]) { // S key

                if ((sin > 0 && collisionX < 1) || (sin < 0 && collisionX > -1)) {
                    playerHitbox.position.x += sin * player.speed;

                }
                if ((cos < 0 && collisionZ < 1) || (cos > 0 && collisionZ > -1)) {
                    playerHitbox.position.z -= cos * player.speed;
                }
            }

            if (keyboard[65]) { // A key
                if ((sinPi > 0 && collisionX < 1) || (sinPi < 0 && collisionX > -1)) {
                    playerHitbox.position.x += sinPi * player.speed;
                }

                if ((cosPi < 0 && collisionZ < 1) || (cosPi > 0 && collisionZ > -1)) {
                    playerHitbox.position.z -= cosPi * player.speed;
                }
            }

            if (keyboard[68]) { // D key
                if ((sinPi < 0 && collisionX < 1) || (sinPi > 0 && collisionX > -1)) {
                    playerHitbox.position.x -= sinPi * player.speed;
                }

                if ((cosPi > 0 && collisionZ < 1) || (cosPi < 0 && collisionZ > -1)) {
                    playerHitbox.position.z += cosPi * player.speed;
                }
            }
        }
        
        function collision() {
            var collisions, i,
                distance = 0.25,
                obstacles = collidableMeshList;

            collisionX = 0;
            collisionZ = 0;

            for (i = 0; i < rays.length; i += 1) {
                caster.set(playerHitbox.position, rays[i]);
                collisions = caster.intersectObjects(obstacles);

                if (collisions.length > 0 && collisions[0].distance <= distance) {
                    if ((i === 1 || i === 2 || i === 3)) {
                        collisionX = 1;
                    } else if ((i === 5 || i === 6 || i === 7)) {
                        collisionX = -1;
                    }
                    if ((i === 0 || i === 1 || i === 7)) {
                        collisionZ = 1;
                    } else if ((i === 3 || i === 4 || i === 5)) {
                        collisionZ = -1;
                    }
                }
            }
        }

        function audio() {
            //up for volume up
            if (keyboard[38])
            {
                if (soundMusic.getVolume() < 0.99) {
                    soundMusic.setVolume(soundMusic.getVolume() + 0.01);
                }
            }
            //down for volume down
            if (keyboard[40])
            {
                if (soundMusic.getVolume() > 0.01) {
                    soundMusic.setVolume(soundMusic.getVolume() - 0.01);
                }
            }
            //m for mute
            if (keyboard[77])
            {
                if (soundMusic.getVolume() > 0) {
                    soundMusic.setVolume(0);
                }
            }
        }

        function keyCheck() {
            // Cast a ray in front of the camera
            var target = new THREE.Vector3(camera.x, camera.y + 0.5, camera.z);
            raycaster.setFromCamera(target, camera);
            // calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0 && intersects[0].distance < 0.2) {
                switch (intersects[0].object.type) {
                    case 'key':
                        //key sound effect
                        // create an AudioListener and add it to the camera
                        var listener = new THREE.AudioListener();
                        camera.add(listener);

                        // create a global audio source
                        var sound = new THREE.Audio(listener);

                        // load a sound and set it as the Audio object's buffer
                        var audioLoader = new THREE.AudioLoader();
                        audioLoader.load('textures/keySound.wav', function (buffer) {
                            sound.setBuffer(buffer);
                            sound.setLoop(false);
                            sound.setVolume(0.5);
                            sound.play();
                        });
                        keyAmount++;
                        scene.remove(intersects[0].object);
                        if (keyAmount === 1) {
                            document.getElementById("key1").src = "textures/keyYellow.png";
                            
                        }

                        if (keyAmount === 2) {
                            document.getElementById("key2").src = "textures/keyYellow.png";
                        }

                        break;

                    case 'end':
                        if (keyAmount === reqKeys) {
                            soundMusic.setVolume(0);
                            //End sound effect
                            // create an AudioListener and add it to the camera
                            var listener = new THREE.AudioListener();
                            camera.add(listener);

                            // create a global audio source
                            var sound = new THREE.Audio(listener);

                            // load a sound and set it as the Audio object's buffer
                            var audioLoader = new THREE.AudioLoader();
                            audioLoader.load('textures/winSound.mp3', function (buffer) {
                                sound.setBuffer(buffer);
                                sound.setLoop(false);
                                sound.setVolume(0.5);
                                sound.play();
                            });
                            setTimeout(5000);
                            restart();
                        }

                        break;

                    default:
                        break;
                }
            }
        }

        // Model Loader [Function]
        function loadOBJModel(modelPath, modelName, texturePath, textureName, onload) {
            new THREE.MTLLoader(loadingManager)
                .setPath(texturePath)
                .load(textureName, function (materials) {

                    materials.preload();

                    new THREE.OBJLoader(loadingManager)
                        .setPath(modelPath)
                        .setMaterials(materials)
                        .load(modelName, function (object) {
                            onload(object);
                        }, function () { }, function (e) { console.log("Error loading model"); console.log(e); });
                });
        }

        function createLight(x, y, z) {
            var torchLight = new THREE.PointLight(0xff9933, 0.65, 1, 2);
            //torchLight.castShadow = true;
            torchLight.shadowDarkness = 0.5;
            torchLight.shadow.radius = 1;
            torchLight.position.set(x, y, z);
            scene.add(torchLight);
            //alert("light pos " + torchLight.position.x + torchLight.position.y + torchLight.position.z);
            return torchLight;
        }

        // Model Deployer [Server]
        function modelDeployer() {
            exampleSocket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/connect_client");
            exampleSocket.onmessage = function (event) {
                var command = parseCommand(event.data);
                console.log(command);
                if (command.command === "update") {
                    if (Object.keys(worldObjects).indexOf(command.parameters.guid) < 0) {
                        switch (command.parameters.type) {
                            case "wall":
                                //Position and Dimensions need to be obtained from the object, but idk if this works
                                var geometry = new THREE.BoxGeometry(1, 1, 0.07);
                                var material = new THREE.MeshLambertMaterial({ map: new THREE.TextureLoader(loadingManager).load("textures/wall.jpg"), side: THREE.DoubleSide/*, transparent: true, opacity: 0.2 */ });
                                var wall = new THREE.Mesh(geometry, material);
                                var walls = new THREE.Group();
                                wall.castShadow = true;
                                walls.add(wall);
                                scene.add(walls);
                                collidableMeshList.push(wall);
                                worldObjects[command.parameters.guid] = walls;

                                break;

                            case "room":
                                switch (command.parameters.roomType) {
                                    case "start":
                                        playerHitbox.position.set(command.parameters.x, player.height, command.parameters.z);
                                        var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                        var mat = new THREE.MeshLambertMaterial({ map: new THREE.TextureLoader(loadingManager).load("textures/start.png"), side: THREE.DoubleSide });
                                        var start = new THREE.Mesh(geo, mat);
                                        scene.add(start);
                                        worldObjects[command.parameters.guid] = start;

                                        break;

                                    case "end":
                                        var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                        var mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
                                        var end = new THREE.Mesh(geo, mat);
                                        end.type = "end";
                                        scene.add(end);
                                        worldObjects[command.parameters.guid] = end;

                                        loadOBJModel("textures/Decoration/", "keyhole.obj", "textures/Decoration/", "keyhole.mtl", (lock) => {
                                            lock.scale.set(0.07, 0.07, 0.07);
                                            lock.position.set(command.parameters.x, command.parameters.y - 0.2, command.parameters.z);
                                            scene.add(lock);
                                        });
                                        createLight(command.parameters.x, command.parameters.y, command.parameters.z);

                                        break;

                                    case "puzzle":
                                        var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                        var mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
                                        var key = new THREE.Mesh(geo, mat);
                                        key.type = "key";

                                        loadOBJModel("textures/Decoration/", "key.obj", "textures/Decoration/", "key.mtl", (oldkey) => {
                                            oldkey.scale.set(1, 1, 1);
                                            key.add(oldkey);
                                            worldObjects[command.parameters.guid] = oldkey;
                                        });
                                        scene.add(key);
                                        worldObjects[command.parameters.guid] = key;

                                        createLight(command.parameters.x, command.parameters.y, command.parameters.z);

                                        break;
                                }

                            case "decoration":
                                //var decorations = new THREE.Group();
                                //worldObjects[command.parameters.guid] = decorations;
                                switch (command.parameters.decoType) {
                                    case "torch":
                                        var torches = new THREE.Group();
                                        worldObjects[command.parameters.guid] = torches;
                                        loadOBJModel("textures/Decoration/", "walltorch.obj", "textures/Decoration/", "walltorch.mtl", (mesh) => {
                                            mesh.scale.set(1, 1, 1);
                                            torches.add(mesh);
                                            scene.add(torches);
                                        });
                                        createLight(command.parameters.x, command.parameters.y - 0.15, command.parameters.z);

                                        break;
                                }

                                break;
                        }
                    }

                    // Object Parameters
                    var object = worldObjects[command.parameters.guid];
                    object.position.x = command.parameters.x;
                    object.position.y = command.parameters.y;
                    object.position.z = command.parameters.z;
                    object.rotation.x = command.parameters.rotationX;
                    object.rotation.y = command.parameters.rotationY;
                    object.rotation.z = command.parameters.rotationZ;
                }
            };
        }

        function restart() {
            exampleSocket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/restart");
            window.location.reload(true);
        } 

        window.onload = init();
    </script>
</body>

</html>