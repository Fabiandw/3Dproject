<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Labyrinth</title>
    <link rel="stylesheet" type="text/css" href="css/index.css" />

    <script src="three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="MTLLoader.js"></script>
    <script src="OBJLoader.js"></script>
</head>

<body style="margin:0px;padding:0px;overflow:hidden;">


    <div id="info">3D Labyrinth</div>
    <div id="help">

        <button class="level" id="level">Level: 1</button>
        <div id="Paragraph">
            <div id="topspan">
                <img class="keys" src="textures/keyBlack.png" alt="key" id="test1" width="50" height="50" />
                <img class="keys" src="textures/keyBlack.png" alt="key" id="test2" width="50" height="50" />


            </div>
        </div>
        <div id="controls">
            <span id="date"></span>
            <span class="wasd">W &emsp; A &emsp; S &emsp; D</span>
        </div>

    </div>



    <script>
        function parseCommand(input = "") {
            return JSON.parse(input);
        }
        var meshFloor, ambientLight, light;
        var crate, crateTexture, crateNormalMap, crateBumpMap;
        var keyboard = {};
        var keyAmount = 0;
        var reqKeys = 2;
        var USE_WIREFRAME = false;
        var RESOURCES_LOADED = false;

        var scene, camera, renderer;
        var cameraControls;
        var exampleSocket;
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(), INTERSECTED;
        var radius = 100, theta = 0;
        var worldObjects = {};

        var rays = [
            new THREE.Vector3(0, 0, 1), // X = | Z +
            new THREE.Vector3(1, 0, 1), // X + | Z +
            new THREE.Vector3(1, 0, 0), // X + | Z =
            new THREE.Vector3(1, 0, -1), // X + | Z -
            new THREE.Vector3(0, 0, -1), // X = | Z -
            new THREE.Vector3(-1, 0, -1), // X - | Z -
            new THREE.Vector3(-1, 0, 0), // X - | Z =
            new THREE.Vector3(-1, 0, 1) // X - | Z +
        ];
        var caster = new THREE.Raycaster();
        var collisionX;
        var collisionZ;
        var collidableMeshList = [];
        var player = { height: 0, speed: 0.04, turnSpeed: Math.PI * 0.02 };
        var playerHitbox;


        function updateTime() {

            var dt = new Date();
            document.getElementById("date").innerHTML = dt.toLocaleTimeString();
        }
        setInterval(updateTime, 1000);

        var button = document.getElementById("level"),
            count = 0;
        button.onclick = function () {
            count += 1;
            button.innerHTML = "Level: " + count;
        };

        function init() {
            // Camera
            loadScene = new THREE.Scene();
            loadCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 4);
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 4);

            //cameraControls = new THREE.OrbitControls(camera);
            //camera.position.x = -50;
            //camera.position.y = 30;
            //camera.position.z = -50;;
            //cameraControls.update();

            //camera.position.set(1, player.height, 1);
            //camera.lookAt(new THREE.Vector3(2, player.height, 2));
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', keyDown);
            window.addEventListener('keyup', keyUp);

            // Interaction
            // window.addEventListener('mousemove', onMouseMove, false);

            // floor

            var floorTexture = new THREE.ImageUtils.loadTexture('textures/floor.jpg');
            floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;

            floorTexture.repeat.set(100, 100);
            var floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture, side: THREE.DoubleSide });
            var floorGeometry = new THREE.PlaneGeometry(50, 50, 10, 10);

            var floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.y = -0.5;
            floor.rotation.x = Math.PI / 2;
            //scene.add(floor);
            floortje = new THREE.Group();
            floortje.add(floor);
            scene.add(floortje);

            //roof
            var roofTexture = new THREE.ImageUtils.loadTexture('textures/roof.jpg');
            roofTexture.wrapS = roofTexture.wrapT = THREE.RepeatWrapping;

            roofTexture.repeat.set(60, 60);
            var roofMaterial = new THREE.MeshPhongMaterial({ map: roofTexture, side: THREE.DoubleSide });
            var roofGeometry = new THREE.PlaneGeometry(50, 50, 10, 10);

            var roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 0.5;
            roof.rotation.x = Math.PI / 2;
            scene.add(roof);
            roofje = new THREE.Group();
            roofje.add(roof);
            scene.add(roofje);

            //Playerlight
            var playerLight = new THREE.PointLight(0xff9933, 0.8, 3.5, 2);
            playerLight.castShadow = true;
            playerLight.shadow.radius = 1.05;

            // Player
            var hitboxGeometery = new THREE.CylinderGeometry(0.25, 0.25, 0.8, 8);
            var hitboxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            playerHitbox = new THREE.Mesh(hitboxGeometery, hitboxMaterial);
            //playerHitbox.position.set(1, -0.1, 1);
            playerHitbox.lookAt(new THREE.Vector3(-Math.PI, player.height, -Math.PI));
            playerHitbox.add(playerLight);
            scene.add(playerHitbox);
            playerHitbox.add(camera);

            // Ambient Light
            //var ambientlight = new THREE.AmbientLight(0x666666); // soft hard light
            //scene.add(ambientlight);

            // Render
            renderer = new THREE.WebGLRenderer();
            renderer.physicallyCorrectLights = true;
            renderer.gammaInput = true;
            renderer.gammaOutput = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.bias = 0.0001;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight + 5);
            document.body.appendChild(renderer.domElement);

            //Loading in models
            modelDeployer();

            requestAnimationFrame(animate);

        }

        // WindowResize [Function]
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        // Animate [Function]
        function animate() {
            requestAnimationFrame(animate);


            if (RESOURCES_LOADED === false) {
                renderer.render(loadScene, loadCamera);
            }

            if (RESOURCES_LOADED === true) {
                renderer.render(scene, camera);
            }
            rotate();
            movement();
            keyCheck();


        }
        function keyDown(event) {
            keyboard[event.keyCode] = true;
        }

        function keyUp(event) {
            keyboard[event.keyCode] = false;
        }

        function rotate() {
            if (keyboard[81]) { // Q key
                playerHitbox.rotation.y -= player.turnSpeed;
            }
            else if (keyboard[37]) { // Left arrow key
                playerHitbox.rotation.y -= player.turnSpeed;
            }
            if (keyboard[69]) { // E key
                playerHitbox.rotation.y += player.turnSpeed;
            }
            else if (keyboard[39]) { // Right arrow key
                playerHitbox.rotation.y += player.turnSpeed;
            }
        }

        function movement() {
            collision();
            var sin = Math.sin(playerHitbox.rotation.y);
            var sinPi = Math.sin(playerHitbox.rotation.y + Math.PI / 2);
            var cos = Math.cos(playerHitbox.rotation.y);
            var cosPi = Math.cos(playerHitbox.rotation.y + Math.PI / 2);

            if (keyboard[87]) { // W key
                if ((sin < 0 && collisionX < 1) || (sin > 0 && collisionX > -1)) {
                    playerHitbox.position.x -= sin * player.speed;
                }

                if ((cos > 0 && collisionZ < 1) || (cos < 0 && collisionZ > -1)) {
                    playerHitbox.position.z += cos * player.speed;
                }
            }

            if (keyboard[83]) { // S key

                if ((sin > 0 && collisionX < 1) || (sin < 0 && collisionX > -1)) {
                    playerHitbox.position.x += sin * player.speed;

                }
                if ((cos < 0 && collisionZ < 1) || (cos > 0 && collisionZ > -1)) {
                    playerHitbox.position.z -= cos * player.speed;
                }
            }

            if (keyboard[65]) { // A key
                if ((sinPi > 0 && collisionX < 1) || (sinPi < 0 && collisionX > -1)) {
                    playerHitbox.position.x += sinPi * player.speed;
                }

                if ((cosPi < 0 && collisionZ < 1) || (cosPi > 0 && collisionZ > -1)) {
                    playerHitbox.position.z -= cosPi * player.speed;
                }
            }

            if (keyboard[68]) { // D key
                if ((sinPi < 0 && collisionX < 1) || (sinPi > 0 && collisionX > -1)) {
                    playerHitbox.position.x -= sinPi * player.speed;
                }

                if ((cosPi > 0 && collisionZ < 1) || (cosPi < 0 && collisionZ > -1)) {
                    playerHitbox.position.z += cosPi * player.speed;
                }
            }
        }

        function collision() {
            var collisions, i,
                distance = 0.25,
                obstacles = collidableMeshList;

            collisionX = 0;
            collisionZ = 0;

            for (i = 0; i < rays.length; i += 1) {
                caster.set(playerHitbox.position, rays[i]);
                collisions = caster.intersectObjects(obstacles);

                if (collisions.length > 0 && collisions[0].distance <= distance) {
                    if ((i === 1 || i === 2 || i === 3)) {
                        collisionX = 1;
                    } else if ((i === 5 || i === 6 || i === 7)) {
                        collisionX = -1;
                    }
                    if ((i === 0 || i === 1 || i === 7)) {
                        collisionZ = 1;
                    } else if ((i === 3 || i === 4 || i === 5)) {
                        collisionZ = -1;
                    }
                }
            }
        }

        function keyCheck() {
            // Cast a ray in front of the camera
            var target = new THREE.Vector3(camera.x, camera.y + 0.5, camera.z);
            raycaster.setFromCamera(target, camera);
            // calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0 && intersects[0].distance < 0.2) {
                switch (intersects[0].object.type) {
                    case 'key':
                        keyAmount++;
                        scene.remove(intersects[0].object);
                        if (keyAmount === 1) {
                            document.getElementById("test1").src = "textures/keyYellow.png";

                        }
                        if (keyAmount === 2) {
                            document.getElementById("test2").src = "textures/keyYellow.png";
                        }
                        break;
                    case 'end':
                        if (keyAmount === reqKeys) {
                            alert("End");
                        }
                        break;

                    default:
                        break;
                }
            }
        }

        function loadOBJModel(modelPath, modelName, texturePath, textureName, onload) {
            new THREE.MTLLoader()
                .setPath(texturePath)
                .load(textureName, function (materials) {

                    materials.preload();

                    new THREE.OBJLoader()
                        .setPath(modelPath)
                        .setMaterials(materials)
                        .load(modelName, function (object) {
                            onload(object);
                        }, function () { }, function (e) { console.log("Error loading model"); console.log(e); });
                });
        }

        function createLight(x, y, z) {
            var torchLight = new THREE.PointLight(0xff9933, 0.65, 1, 2);
            //torchLight.castShadow = true;
            torchLight.shadowDarkness = 0.5;
            torchLight.shadow.radius = 1;
            torchLight.position.set(x, y, z);
            scene.add(torchLight);
            //alert("light pos " + torchLight.position.x + torchLight.position.y + torchLight.position.z);
            return torchLight;
        }

        // Model Deployer [Server]
        function modelDeployer() {
            exampleSocket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/connect_client");
            exampleSocket.onmessage = function (event) {
                var command = parseCommand(event.data);
                console.log(command);
                if (command.command === "update") {
                    if (Object.keys(worldObjects).indexOf(command.parameters.guid) < 0) {
                        switch (command.parameters.type) {
                            case "wall":
                                {
                                    //Position and Dimensions need to be obtained from the object, but idk if this works
                                    var geometry = new THREE.BoxGeometry(1, 1, 0.07);
                                    var material = new THREE.MeshLambertMaterial({ map: new THREE.TextureLoader().load("textures/wall.jpg"), side: THREE.DoubleSide/*, transparent: true, opacity: 0.2 */ });
                                    var wall = new THREE.Mesh(geometry, material);
                                    var walls = new THREE.Group();
                                    wall.castShadow = true;
                                    walls.add(wall);
                                    scene.add(walls);
                                    collidableMeshList.push(wall);
                                    worldObjects[command.parameters.guid] = walls;
                                }
                                break;
                            //case "roof":
                            //    {
                            //        var roofTexture = new THREE.ImageUtils.loadTexture('textures/roof.jpg');
                            //        roofTexture.wrapS = roofTexture.wrapT = THREE.RepeatWrapping;

                            //        roofTexture.repeat.set(command.parameters.x, command.parameters.z);
                            //        var roofMaterial = new THREE.MeshPhongMaterial({ map: roofTexture, side: THREE.DoubleSide });
                            //        var roofGeometry = new THREE.PlaneGeometry(command.parameters.x * 2, command.parameters.z*2, 1, 1);

                            //        var roof = new THREE.Mesh(roofGeometry, roofMaterial);
                            //        roof.position.x = command.parameters.x;
                            //        roof.position.z = command.parameters.z;
                            //        roof.position.y = 0.5;
                            //        roof.rotation.x = Math.PI / 2;
                            //        scene.add(roof);
                            //        worldObjects[command.parameters.guid] = roof;
                            //    }
                            //    break;
                            //case "floor":
                            //    {
                            //        var floorTexture = new THREE.ImageUtils.loadTexture('textures/floor.jpg');
                            //        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;

                            //        floorTexture.repeat.set(command.parameters.x, command.parameters.z);
                            //        var floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture, side: THREE.DoubleSide });
                            //        var floorGeometry = new THREE.PlaneGeometry(command.parameters.x * 2, command.parameters.z * 2, 1, 1);

                            //        var floor = new THREE.Mesh(floorGeometry, floorMaterial);
                            //        floor.position.x = command.parameters.x;
                            //        floor.position.z = command.parameters.z;
                            //        floor.position.y = -0.5;
                            //        floor.rotation.x = Math.PI / 2;
                            //        scene.add(floor);
                            //        worldObjects[command.parameters.guid] = floor;
                            //    }
                            //    break;

                            case "start":
                                {
                                    playerHitbox.position.set(command.parameters.x, player.height, command.parameters.z);
                                    var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                    var mat = new THREE.MeshLambertMaterial({ map: new THREE.TextureLoader().load("textures/start.png"), side: THREE.DoubleSide });
                                    var start = new THREE.Mesh(geo, mat);
                                    scene.add(start);
                                    worldObjects[command.parameters.guid] = start;
                                }
                                break;
                            case "end":

                                {
                                    var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                    var mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
                                    var end = new THREE.Mesh(geo, mat);
                                    end.type = "end";
                                    scene.add(end);
                                    worldObjects[command.parameters.guid] = end;

                                    loadOBJModel("textures/Decoration/", "keyhole.obj", "textures/Decoration/", "keyhole.mtl", (lock) => {
                                        lock.scale.set(0.07, 0.07, 0.07);
                                        lock.position.set(command.parameters.x, command.parameters.y - 0.2, command.parameters.z);
                                        scene.add(lock);
                                    });
                                    createLight(command.parameters.x, command.parameters.y, command.parameters.z);
                                }
                                break;

                            case "puzzle":
                                {
                                    var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                    var mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
                                    var key = new THREE.Mesh(geo, mat);
                                    key.type = "key";

                                    loadOBJModel("textures/Decoration/", "key.obj", "textures/Decoration/", "key.mtl", (oldkey) => {
                                        oldkey.scale.set(1, 1, 1);
                                        key.add(oldkey);
                                        worldObjects[command.parameters.guid] = oldkey;
                                    });
                                    scene.add(key);
                                    worldObjects[command.parameters.guid] = key;

                                    createLight(command.parameters.x, command.parameters.y, command.parameters.z);
                                }
                                break;

                            case "decoration":
                                {
                                    //var decorations = new THREE.Group();
                                    //worldObjects[command.parameters.guid] = decorations;
                                    switch (command.parameters.decoType) {
                                        case "torch":
                                            {
                                                var torches = new THREE.Group();
                                                worldObjects[command.parameters.guid] = torches;
                                                loadOBJModel("textures/Decoration/", "walltorch.obj", "textures/Decoration/", "walltorch.mtl", (mesh) => {
                                                    mesh.scale.set(1, 1, 1);
                                                    torches.add(mesh);
                                                    scene.add(torches);
                                                });
                                                createLight(command.parameters.x, command.parameters.y - 0.15, command.parameters.z);
                                            }
                                            break;

                                        // Last object in WorldObjects, loadingscreen purpose only
                                        case "TESTOBJ": {
                                            RESOURCES_LOADED = true;
                                        }
                                    }
                                }
                                break;
                        }
                    }

                    // Object Parameters
                    var object = worldObjects[command.parameters.guid];
                    object.position.x = command.parameters.x;
                    object.position.y = command.parameters.y;
                    object.position.z = command.parameters.z;
                    object.rotation.x = command.parameters.rotationX;
                    object.rotation.y = command.parameters.rotationY;
                    object.rotation.z = command.parameters.rotationZ;
                }
            };

        }
        window.onload = init();
    </script>
    <embed name="GoodEnough" src="/textures/song.mp3" loop="false" hidden="true" autostart="true">
</body>

</html>