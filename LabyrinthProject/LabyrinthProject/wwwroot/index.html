<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Labyrinth</title>
    <link rel="stylesheet" type="text/css" href="css/index.css" />
    <link rel="stylesheet" href="css/Main.css" type="text/css" />

    <script type="text/javascript" src="three.min.js"></script>
    <script type="text/javascript" src="MTLLoader.js"></script>
    <script type="text/javascript" src="OBJLoader.js"></script>
</head>

<body style="margin:0px;padding:0px;overflow:hidden;">

    <div class="menu" style="width: 100%;" hidden>
        <div class="wrap">
            <p id="option"><b id="start">Start Game</b></p>
            <p id="option"><b><a href="Instructions.html" id="start">Instructions</a></b></p>
        </div>
    </div>

    <div id="loadingText">Please wait while the world is loading...</div>

    <div id="title">3D Labyrinth</div>

    <div id="userInterface">
        <div id="topspan">
            <img class="keys" src="textures/keyBlack.png" alt="key" id="key1" width="75" height="75" />
            <img class="keys" src="textures/keyBlack.png" alt="key" id="key2" width="75" height="75" />
        </div>
        <div id="controls">
            <span id="date"></span>
            <paragraph id="wasd">
                <p align="left">W: Move Forwards</p>
                <p align="left">S: Move Backwards</p>
                <p align="left">A: Move Left</p>
                <p align="left">D: Move Right</p>
                <p align="left">Q: Rotate Left</p>
                <p align="left">E: Rotate Right</p>
                <p align="left">Arrow keys also rotate</p>
            </paragraph>
        </div>
    </div>

    <script>
        function parseCommand(input = "") {
            return JSON.parse(input);
        }

        var tloader = new THREE.TextureLoader();
        var meshFloor, ambientLight, light;
        var crate, crateTexture, crateNormalMap, crateBumpMap;
        var keyboard = {};
        var collidableMeshList = [];
        var player = { height: 0, speed: 0.02, turnSpeed: Math.PI * 0.015 };
        var playerHitbox;

        var renderer, scene, camera;
        var cameraControls;
        var exampleSocket;

        var keyAmount = 0;
        var reqKeys = 2;

        var raycaster = new THREE.Raycaster();
        var worldObjects = {};

        var rays = [
            new THREE.Vector3(0, 0, 1), // X = | Z +
            new THREE.Vector3(1, 0, 1), // X + | Z +
            new THREE.Vector3(1, 0, 0), // X + | Z =
            new THREE.Vector3(1, 0, -1), // X + | Z -
            new THREE.Vector3(0, 0, -1), // X = | Z -
            new THREE.Vector3(-1, 0, -1), // X - | Z -
            new THREE.Vector3(-1, 0, 0), // X - | Z =
            new THREE.Vector3(-1, 0, 1) // X - | Z +
        ];
        var caster = new THREE.Raycaster();
        var collisionX;
        var collisionZ;


        function updateTime() {

            var dt = new Date();
            document.getElementById("date").innerHTML = dt.toLocaleTimeString();
        }
        setInterval(updateTime, 1000);

        var loadingScreen = {
            scene: new THREE.Scene(),
            camera: new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100),
            box: new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 0.5),
                new THREE.MeshBasicMaterial({ map: tloader.load("textures/pepe.png") })
            )
        };

        var loadingManager;
        var RESOURCES_LOADED = false;

        function init() {
            // Loading screen
            loadingScreen.box.position.set(0, 0, 2);
            loadingScreen.camera.lookAt(loadingScreen.box.position);
            loadingScreen.scene.add(loadingScreen.box);

            // Loading manager
            loadingManager = new THREE.LoadingManager();
            loadingManager.onLoad = function () {
                RESOURCES_LOADED = true;
            }

            requestAnimationFrame(animate);

            // Camera
            scene = new THREE.Scene();
<<<<<<< HEAD
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5);
=======
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 6);
>>>>>>> master

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', keyDown);
            window.addEventListener('keyup', keyUp);

            // Playerlight
            var playerLight = new THREE.PointLight(0xff9933, 0.8, 3.5, 2);
            playerLight.castShadow = true;

            // Player
            var hitboxGeometery = new THREE.CylinderGeometry(0.25, 0.25, 1, 8);
            var hitboxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            playerHitbox = new THREE.Mesh(hitboxGeometery, hitboxMaterial);
            playerHitbox.lookAt(new THREE.Vector3(-1, player.height, -1));
            playerHitbox.add(playerLight);
            scene.add(playerHitbox);
            playerHitbox.add(camera);

            // Render
            renderer = new THREE.WebGLRenderer();
            renderer.physicallyCorrectLights = true;
            renderer.gammaInput = true;
            renderer.gammaOutput = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.bias = 0.0001;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight + 5);
            document.body.appendChild(renderer.domElement);

            // Loading in models
            modelDeployer();

            requestAnimationFrame(animate);
        }

        // WindowResize [Function]
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animate [Function]
        function animate() {
            if (RESOURCES_LOADED === false) {
                requestAnimationFrame(animate);

                var loadingText = document.getElementById('loadingText');
                loadingText.style.visibility = "visible";

                var userInterface = document.getElementById('userInterface');
                userInterface.style.visibility = "hidden";

                loadingScreen.box.rotation.x -= 0.01;
                loadingScreen.box.rotation.y -= 0.01;
                loadingScreen.box.rotation.z -= 0.01;

                renderer.render(loadingScreen.scene, loadingScreen.camera);
                return;
            }

            if (RESOURCES_LOADED === true) {
                requestAnimationFrame(animate);

                var loadingText = document.getElementById('loadingText');
                loadingText.style.visibility = "hidden";

                var userInterface = document.getElementById('userInterface');
                userInterface.style.visibility = "visible";

                renderer.render(scene, camera);
            }
            rotate();
            movement();
            keyCheck();
        }

        function keyDown(event) {
            keyboard[event.keyCode] = true;
        }

        function keyUp(event) {
            keyboard[event.keyCode] = false;
        }

        function rotate() {
            if (keyboard[81]) { // Q key
                playerHitbox.rotation.y -= player.turnSpeed;
            }
            else if (keyboard[37]) { // Left arrow key
                playerHitbox.rotation.y -= player.turnSpeed;
            }
            if (keyboard[69]) { // E key
                playerHitbox.rotation.y += player.turnSpeed;
            }
            else if (keyboard[39]) { // Right arrow key
                playerHitbox.rotation.y += player.turnSpeed;
            }
        }

        function movement() {
            collision();
            var sin = Math.sin(playerHitbox.rotation.y);
            var sinPi = Math.sin(playerHitbox.rotation.y + Math.PI / 2);
            var cos = Math.cos(playerHitbox.rotation.y);
            var cosPi = Math.cos(playerHitbox.rotation.y + Math.PI / 2);

            if (keyboard[87]) { // W key
                if ((sin < 0 && collisionX < 1) || (sin > 0 && collisionX > -1)) {
                    playerHitbox.position.x -= sin * player.speed;
                }

                if ((cos > 0 && collisionZ < 1) || (cos < 0 && collisionZ > -1)) {
                    playerHitbox.position.z += cos * player.speed;
                }
            }

            if (keyboard[83]) { // S key

                if ((sin > 0 && collisionX < 1) || (sin < 0 && collisionX > -1)) {
                    playerHitbox.position.x += sin * player.speed;

                }
                if ((cos < 0 && collisionZ < 1) || (cos > 0 && collisionZ > -1)) {
                    playerHitbox.position.z -= cos * player.speed;
                }
            }

            if (keyboard[65]) { // A key
                if ((sinPi > 0 && collisionX < 1) || (sinPi < 0 && collisionX > -1)) {
                    playerHitbox.position.x += sinPi * player.speed;
                }

                if ((cosPi < 0 && collisionZ < 1) || (cosPi > 0 && collisionZ > -1)) {
                    playerHitbox.position.z -= cosPi * player.speed;
                }
            }

            if (keyboard[68]) { // D key
                if ((sinPi < 0 && collisionX < 1) || (sinPi > 0 && collisionX > -1)) {
                    playerHitbox.position.x -= sinPi * player.speed;
                }

                if ((cosPi > 0 && collisionZ < 1) || (cosPi < 0 && collisionZ > -1)) {
                    playerHitbox.position.z += cosPi * player.speed;
                }
            }
        }

        function collision() {
            var collisions, i,
                distance = 0.25,
                obstacles = collidableMeshList;

            collisionX = 0;
            collisionZ = 0;

            for (i = 0; i < rays.length; i += 1) {
                caster.set(playerHitbox.position, rays[i]);
                collisions = caster.intersectObjects(obstacles);

                if (collisions.length > 0 && collisions[0].distance <= distance) {
                    if ((i === 1 || i === 2 || i === 3)) {
                        collisionX = 1;
                    } else if ((i === 5 || i === 6 || i === 7)) {
                        collisionX = -1;
                    }
                    if ((i === 0 || i === 1 || i === 7)) {
                        collisionZ = 1;
                    } else if ((i === 3 || i === 4 || i === 5)) {
                        collisionZ = -1;
                    }
                }
            }
        }

        function keyCheck() {
            // Cast a ray in front of the camera
            var target = new THREE.Vector3(camera.x, camera.y + 0.5, camera.z);
            raycaster.setFromCamera(target, camera);
            // calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0 && intersects[0].distance < 0.2) {
                switch (intersects[0].object.type) {
                    case 'key':
                        keyAmount++;
                        scene.remove(intersects[0].object);
                        if (keyAmount === 1) {
                            document.getElementById("key1").src = "textures/keyYellow.png";
                        }

                        if (keyAmount === 2) {
                            document.getElementById("key2").src = "textures/keyYellow.png";
                        }

                        break;

                    case 'end':
                        if (keyAmount === reqKeys) {
                            restart();
                        }

                        break;

                    default:
                        break;
                }
            }
        }

        // Model Loader [Function]
        function loadOBJModel(modelPath, modelName, texturePath, textureName, onload) {
            new THREE.MTLLoader(loadingManager)
                .setPath(texturePath)
                .load(textureName, function (materials) {

                    materials.preload();

                    new THREE.OBJLoader(loadingManager)
                        .setPath(modelPath)
                        .setMaterials(materials)
                        .load(modelName, function (object) {
                            onload(object);
                        }, function () { }, function (e) { console.log("Error loading model"); console.log(e); });
                });
        }

        function createLight(x, y, z) {
<<<<<<< HEAD
            var torchLight = new THREE.PointLight(0xff9933, 0.65, 1, 2);
            torchLight.castShadow = false;
=======
            var torchLight = new THREE.PointLight(0xff5500, 0.2, 0.5, 2);
            //torchLight.castShadow = true;
>>>>>>> master
            torchLight.shadowDarkness = 0.5;
            torchLight.shadow.radius = 1;
            torchLight.position.set(x, y, z);
            scene.add(torchLight);
            //alert("light pos " + torchLight.position.x + torchLight.position.y + torchLight.position.z);
            return torchLight;
        }

        // Model Deployer [Server]
        function modelDeployer() {
            exampleSocket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/connect_client");
            exampleSocket.onmessage = function (event) {
                var command = parseCommand(event.data);
                console.log(command);
                if (command.command === "update") {
                    if (Object.keys(worldObjects).indexOf(command.parameters.guid) < 0) {
                        switch (command.parameters.type) {
                            case "wall":
                                //Position and Dimensions need to be obtained from the object, but idk if this works
                                var geometry = new THREE.BoxGeometry(1, 1, 0.07);
                                var material = new THREE.MeshLambertMaterial({ map: tloader.load("textures/wall.jpg"), side: THREE.DoubleSide/*, transparent: true, opacity: 0.2 */ });
                                var wall = new THREE.Mesh(geometry, material);
                                var walls = new THREE.Group();
                                wall.castShadow = true;
                                walls.add(wall);
                                scene.add(walls);
                                collidableMeshList.push(wall);
                                worldObjects[command.parameters.guid] = walls;

                                break;

                            case "room":
                                switch (command.parameters.roomType) {
                                    case "start":
                                        playerHitbox.position.set(command.parameters.x, player.height, command.parameters.z);
                                        var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                        var mat = new THREE.MeshLambertMaterial({ map: tloader.load("textures/start.png"), side: THREE.DoubleSide });
                                        var start = new THREE.Mesh(geo, mat);
                                        scene.add(start);
                                        worldObjects[command.parameters.guid] = start;

                                        break;

                                    case "end":
                                        var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                        var mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
                                        var end = new THREE.Mesh(geo, mat);
                                        end.type = "end";
                                        scene.add(end);
                                        worldObjects[command.parameters.guid] = end;

                                        loadOBJModel("textures/Decoration/", "keyhole.obj", "textures/Decoration/", "keyhole.mtl", (lock) => {
                                            lock.scale.set(0.07, 0.07, 0.07);
                                            lock.position.set(command.parameters.x, command.parameters.y - 0.2, command.parameters.z);
                                            scene.add(lock);
                                        });
                                        createLight(command.parameters.x, command.parameters.y, command.parameters.z);

                                        break;

                                    case "puzzle":
                                        var geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                                       var mat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
                                        var key = new THREE.Mesh(geo, mat);
                                        key.type = "key";

                                        loadOBJModel("textures/Decoration/", "key.obj", "textures/Decoration/", "key.mtl", (oldkey) => {
                                            oldkey.scale.set(1, 1, 1);
                                            key.add(oldkey);
                                            worldObjects[command.parameters.guid] = oldkey;
                                        });
                                        scene.add(key);
                                        worldObjects[command.parameters.guid] = key;

                                        createLight(command.parameters.x, command.parameters.y, command.parameters.z);

                                        break;
                                }

                            case "decoration":
                                //var decorations = new THREE.Group();
                                //worldObjects[command.parameters.guid] = decorations;
                                switch (command.parameters.decoType) {
                                    case "torch":
                                        var torches = new THREE.Group();
                                        worldObjects[command.parameters.guid] = torches;
                                        loadOBJModel("textures/Decoration/", "walltorch.obj", "textures/Decoration/", "walltorch.mtl", (mesh) => {
                                            mesh.scale.set(1, 1, 1);
                                            torches.add(mesh);
                                            scene.add(torches);
                                        });
                                        createLight(command.parameters.x, command.parameters.y - 0.15, command.parameters.z);

                                        break;
                                }

                                break;
                            case "roof":
                                {
                                    var roofTexture = tloader.load('textures/roof-min.jpg', function (texture) {

                                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                                        texture.offset.set(0, 0);
                                        texture.repeat.set(command.parameters.x*3, command.parameters.z*3);

                                    });
                                    var roofMaterial = new THREE.MeshPhongMaterial({ map: roofTexture, side: THREE.DoubleSide });
                                    var roofGeometry = new THREE.PlaneGeometry(command.parameters.x*3,command.parameters.z*3, 10, 10);
                                    var roof = new THREE.Mesh(roofGeometry, roofMaterial);
                                    roof.rotation.x = Math.PI / 2;
                                    roof.position.y = 0.5;
                                    roof.position.x =  1;
                                    roof.position.z =  1;
                                    roofGroup = new THREE.Group();
                                    roofGroup.add(roof);
                                    scene.add(roofGroup);
                                    worldObjects[command.parameters.guid] = roofGroup;
                                }
                                break;
                            case "floor":
                                {
                                    var floorTexture = tloader.load('textures/floor-min.jpg', function (texture) {

                                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                                        texture.offset.set(0, 0);
                                        texture.repeat.set(command.parameters.x*3, command.parameters.z*3);

                                    });
                                    var floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture, side: THREE.DoubleSide });
                                    var floorGeometry = new THREE.PlaneGeometry(command.parameters.x * 3, command.parameters.z * 3, 10, 10);
                                    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
                                    floor.rotation.x = Math.PI / 2;
                                    floor.position.y = -0.5;
                                    floor.position.x = 1;
                                    floor.position.z = 1;
                                    floorGroup = new THREE.Group();
                                    floorGroup.add(floor);
                                    scene.add(floorGroup);
                                    worldObjects[command.parameters.guid] = floorGroup;
                                }
                                break;
                        }
                    }

                    // Object Parameters
                    var object = worldObjects[command.parameters.guid];
                    object.position.x = command.parameters.x;
                    object.position.y = command.parameters.y;
                    object.position.z = command.parameters.z;
                    object.rotation.x = command.parameters.rotationX;
                    object.rotation.y = command.parameters.rotationY;
                    object.rotation.z = command.parameters.rotationZ;
                }
            };
        }

        // Server Restart [Server]
        function restart() {
            exampleSocket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/restart");
            window.location.reload(true);
        }

        window.onload = init();
    </script>
    <embed name="GoodEnough" src="/textures/song.mp3" loop="true" hidden autostart="true">
</body>

</html>