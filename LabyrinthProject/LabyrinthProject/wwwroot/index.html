<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Labyrinth</title>
    <script type="text/javascript" src="three.min.js"></script>
    <script type="text/javascript" src="OrbitControls.js"></script>
    <script type="text/javascript" src="MTLLoader.js"></script>
    <script type="text/javascript" src="OBJLoader.js"></script>
</head>

<body style="margin:0px;padding:0px;overflow:hidden;">
    <div id="viewport"></div>

    <script type="text/javascript">
        function parseCommand(input = "") {
            return JSON.parse(input);
        }

        var meshFloor, ambientLight, light;
        var crate, crateTexture, crateNormalMap, crateBumpMap;
        var keyboard = {};
        var collidableMeshList = [];
        var player = { height: 0, speed: 0.05, turnSpeed: Math.PI * 0.02 };
        var playerHitbox;

        var renderer, scene, camera;
        var cameraControls;
        var exampleSocket;

        var rays = [
            new THREE.Vector3(0, 0, 1), // X = | Z +
            new THREE.Vector3(1, 0, 1), // X + | Z +
            new THREE.Vector3(1, 0, 0), // X + | Z =
            new THREE.Vector3(1, 0, -1), // X + | Z -
            new THREE.Vector3(0, 0, -1), // X = | Z -
            new THREE.Vector3(-1, 0, -1), // X - | Z -
            new THREE.Vector3(-1, 0, 0), // X - | Z =
            new THREE.Vector3(-1, 0, 1) // X - | Z +
        ];

        var caster = new THREE.Raycaster();
        var collisionX;
        var collisionZ;

        var worldObjects = {};

        function init() {
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight + 5);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            document.getElementById('viewport').appendChild(renderer.domElement);

            // Scene
            scene = new THREE.Scene;

            // Camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);

            //cameraControls = new THREE.OrbitControls(camera);
            //camera.position.set(-25, 30, -25);
            //cameraControls.update();

            //camera.position.set(1, player.height, 1);
            //camera.lookAt(new THREE.Vector3(2, player.height, 2));

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', keyDown);
            window.addEventListener('keyup', keyUp);

            // Plane
            var planeGeometry = new THREE.PlaneGeometry(100, 100, 32);
            var planeMaterial = new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/moonsurface.jpg"), side: THREE.DoubleSide });
            var plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            plane.position.y = -0.5
            scene.add(plane);

            // Player
            var hitboxGeometery = new THREE.CylinderGeometry(0.25, 0.25, 0.8, 8);
            var hitboxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            playerHitbox = new THREE.Mesh(hitboxGeometery, hitboxMaterial);
            playerHitbox.position.set(1, -0.1, 1);
            playerHitbox.lookAt(new THREE.Vector3(-2, player.height - 0.1, -2));
            scene.add(playerHitbox);
            playerHitbox.add(camera);

            // Ambient Light
            ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            //Loading in models
            modelDeployer();

            requestAnimationFrame(animate);
        }

        // WindowResize [Function]
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animate [Function]
        function animate() {
            rotate();
            movement();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        function keyDown(event) {
            keyboard[event.keyCode] = true;
        }

        function keyUp(event) {
            keyboard[event.keyCode] = false;
        }

        function collision() {
            var collisions, i,
                distance = 0.25,
                obstacles = collidableMeshList;

            collisionX = 0;
            collisionZ = 0;

            for (i = 0; i < rays.length; i += 1) {
                caster.set(playerHitbox.position, rays[i]);
                collisions = caster.intersectObjects(obstacles);

                if (collisions.length > 0 && collisions[0].distance <= distance) {
                    if ((i === 1 || i === 2 || i === 3)) {
                        collisionX = 1;
                    } else if ((i === 5 || i === 6 || i === 7)) {
                        collisionX = -1;
                    }
                    if ((i === 0 || i === 1 || i === 7)) {
                        collisionZ = 1;
                    } else if ((i === 3 || i === 4 || i === 5)) {
                        collisionZ = -1;
                    }
                }
            }
        }

        function rotate() {
            if (!((keyboard[87] || keyboard[83]) && (keyboard[65] || keyboard[68]))) {
                if (keyboard[81]) { // Q key
                    playerHitbox.rotation.y -= player.turnSpeed;
                }
                else if (keyboard[37]) { // Left arrow key
                    playerHitbox.rotation.y -= player.turnSpeed;
                }
                if (keyboard[69]) { // E key
                    playerHitbox.rotation.y += player.turnSpeed;
                }
                else if (keyboard[39]) { // Right arrow key
                    playerHitbox.rotation.y += player.turnSpeed;
                }
            }
        }

        function movement() {
            collision();
            var position = playerHitbox.position.clone();
            var moveX;
            var moveZ;

            if (keyboard[87]) { // W key
                if (position.x < position.x - Math.sin(playerHitbox.rotation.y) * player.speed) {
                    if (collisionX !== 1) {
                        moveX = true;
                    }
                }
                else if (position.x > position.x - Math.sin(playerHitbox.rotation.y) * player.speed) {
                    if (collisionX !== -1) {
                        moveX = true;
                    }
                }

                if (position.z < position.z - -Math.cos(playerHitbox.rotation.y) * player.speed) {
                    if (collisionZ !== 1) {
                        moveZ = true;
                    }
                }
                else if (position.z > position.z - -Math.cos(playerHitbox.rotation.y) * player.speed) {
                    if (collisionZ !== -1) {
                        moveZ = true;
                    }
                }

                if (moveX === true && moveZ === true) {
                    playerHitbox.position.x -= Math.sin(playerHitbox.rotation.y) * player.speed;
                    playerHitbox.position.z -= -Math.cos(playerHitbox.rotation.y) * player.speed;
                }
            }

            if (keyboard[83]) { // S key
                if (position.x < position.x + Math.sin(playerHitbox.rotation.y) * player.speed) {
                    if (collisionX !== 1) {
                        moveX = true;
                    }
                }
                else if (position.x > position.x + Math.sin(playerHitbox.rotation.y) * player.speed) {
                    if (collisionX !== -1) {
                        moveX = true;
                    }
                }

                if (position.z < position.z + -Math.cos(playerHitbox.rotation.y) * player.speed) {
                    if (collisionZ !== 1) {
                        moveZ = true;
                    }
                }
                else if (position.z > position.z + -Math.cos(playerHitbox.rotation.y) * player.speed) {
                    if (collisionZ !== -1) {
                        moveZ = true;
                    }
                }

                if (moveX === true && moveZ === true) {
                    playerHitbox.position.x += Math.sin(playerHitbox.rotation.y) * player.speed;
                    playerHitbox.position.z += -Math.cos(playerHitbox.rotation.y) * player.speed;
                }
            }

            if (keyboard[65]) { // A key
                if (position.x < position.x + Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionX !== 1) {
                        moveX = true;
                    }
                }
                else if (position.x > position.x + Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionX !== -1) {
                        moveX = true;
                    }
                }

                if (position.z < position.z + -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionZ !== 1) {
                        moveZ = true;
                    }
                }
                else if (position.z > position.z + -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionZ !== -1) {
                        moveZ = true;
                    }
                }

                if (moveX === true && moveZ === true) {
                    playerHitbox.position.x += Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed;
                    playerHitbox.position.z += -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed;
                }
            }

            if (keyboard[68]) { // D key
                if (position.x < position.x - Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionX !== 1) {
                        moveX = true;
                    }
                }
                else if (position.x > position.x - Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionX !== -1) {
                        moveX = true;
                    }
                }

                if (position.z < position.z - -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionZ !== 1) {
                        moveZ = true;
                    }
                }
                else if (position.z > position.z - -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed) {
                    if (collisionZ !== -1) {
                        moveZ = true;
                    }
                }

                if (moveX === true && moveZ === true) {
                    playerHitbox.position.x -= Math.sin(playerHitbox.rotation.y + Math.PI / 2) * player.speed;
                    playerHitbox.position.z -= -Math.cos(playerHitbox.rotation.y + Math.PI / 2) * player.speed;
                }
            }
        }

        // Model Loader [Function]
        function loadOBJModel(modelPath, modelName, texturePath, textureName, onload) {
            new THREE.MTLLoader()
                .setPath(texturePath)
                .load(textureName, function (materials) {

                    materials.preload();

                    new THREE.OBJLoader()
                        .setPath(modelPath)
                        .setMaterials(materials)
                        .load(modelName, function (object) {
                            onload(object);
                        }, function () { }, function (e) { console.log("Error loading model"); console.log(e); });
                });
        }

        // Model Deployer [Server]
        function modelDeployer() {
            exampleSocket = new WebSocket("ws://" + window.location.hostname + ":" + window.location.port + "/connect_client");
            exampleSocket.onmessage = function (event) {
                var command = parseCommand(event.data);
                console.log(command);
                if (command.command === "update") {
                    if (Object.keys(worldObjects).indexOf(command.parameters.guid) < 0) {
                        switch (command.parameters.type) {
                            case "wall":
                                {
                                    //Position and Dimensions need to be optained from the object, but idk if this works
                                    var geometry = new THREE.BoxGeometry(1, 1, 0.05);
                                    var material = new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load("textures/wolla.jpg"), side: THREE.DoubleSide });
                                    var wall = new THREE.Mesh(geometry, material);
                                    scene.add(wall);
                                    collidableMeshList.push(wall);
                                    worldObjects[command.parameters.guid] = wall;
                                }
                                break;

                            case "decoration":
                                {
                                    var decorations = new THREE.Group();
                                    worldObjects[command.parameters.guid] = decorations;

                                    //Examples of decoration types
                                    if (command.parameters.decoType === "tree") {
                                        loadOBJModel("models/tree/", "tree.obj", "models/tree/", "tree.mtl", (mesh) => {
                                            decorations.add(mesh);
                                            scene.add(decorations);
                                        });
                                    }
                                    else if (command.parameters.decoType === "torch") {
                                        loadOBJModel("models/torch/", "torch.obj", "models/torch/", "torch.mtl", (mesh) => {
                                            decorations.add(mesh);
                                            scene.add(decorations);
                                        });
                                    }

                                }
                                break;
                        }
                    }
                    // Object Parameters
                    var object = worldObjects[command.parameters.guid];
                    object.position.x = command.parameters.x;
                    object.position.y = command.parameters.y;
                    object.position.z = command.parameters.z;
                    object.rotation.x = command.parameters.rotationX;
                    object.rotation.y = command.parameters.rotationY;
                    object.rotation.z = command.parameters.rotationZ;
                }
            };
        }

        window.onload = init();
    </script>
</body>

</html>